name: Build and Push Ansible Execution Environment

on:
  push:
    branches:
      - main
      - playbook-nest
    paths:
      - 'Containerfile.ubi-micro'
      - 'execution-environment.yml'
      - 'ansible.cfg'
      - 'requirements.yml'
      - 'requirements.txt'
      - 'bindep.txt'
      - '.github/workflows/build-execution-environment.yml'
  pull_request:
    branches:
      - main
    paths:
      - 'Containerfile.ubi-micro'
      - 'execution-environment.yml'
      - 'ansible.cfg'
      - 'requirements.yml'
      - 'requirements.txt'
      - 'bindep.txt'
      - '.github/workflows/build-execution-environment.yml'
  workflow_dispatch:
    inputs:
      push_to_registry:
        description: 'Push image to GHCR (main branch only)'
        required: false
        default: false
        type: boolean

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}/ansible-ee
  COLLECTION_NAMESPACE: kush_gupt
  COLLECTION_NAME: ed_25_03

jobs:
  build-execution-environment:
    name: Build Ansible Execution Environment
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      id-token: write
      attestations: write
    outputs:
      image-digest: ${{ steps.push.outputs.digest }}
      image-tags: ${{ steps.meta.outputs.tags }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Prepare build context
        run: |
          # Copy the ansible requirements to root for Containerfile
          cp ansible/requirements.yml ./requirements.yml
          
          # Verify all required files exist for UBI Micro build
          echo "=== Checking build files ==="
          ls -la
          
          echo "=== Verifying Containerfile.ubi-micro exists ==="
          if [ ! -f "Containerfile.ubi-micro" ]; then
            echo "ERROR: Containerfile.ubi-micro not found!"
            exit 1
          fi
          cat Containerfile.ubi-micro
          
          echo ""
          echo "=== Ansible Configuration ==="
          cat ansible.cfg
          echo ""
          echo "=== Collection Requirements ==="
          cat requirements.yml
          echo ""
          echo "=== Python Requirements ==="
          cat requirements.txt
          
      - name: Set up Podman
        run: |
          echo "=== Podman Version ==="
          podman version
          
          echo "=== Podman Info ==="
          podman info

      - name: Log in to Container Registry
        if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/playbook-nest') || (github.event_name == 'workflow_dispatch' && inputs.push_to_registry)
        run: |
          echo "${{ secrets.GITHUB_TOKEN }}" | podman login ${{ env.REGISTRY }} -u ${{ github.actor }} --password-stdin

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix=sha-
            type=raw,value=latest,enable={{is_default_branch}}
          labels: |
            org.opencontainers.image.title=CISA ED 25-03 Ansible Execution Environment
            org.opencontainers.image.description=Ansible execution environment for CISA ED 25-03 Core Dump & Hunt automation (Cisco ASA)
            org.opencontainers.image.vendor=CISA ED 25-03 Project
            org.opencontainers.image.licenses=Apache-2.0

      - name: Build execution environment with UBI Micro
        id: build
        run: |
          echo "=== Building with UBI Micro (smallest Red Hat base) ==="
          
          # Build using custom Containerfile.ubi-micro for multi-stage build
          # This provides smallest image size (~140-180MB) with minimal attack surface
          podman build \
            -f Containerfile.ubi-micro \
            -t temp-ee:latest \
            --layers=true \
            --force-rm \
            .
          
          # Get the image ID
          IMAGE_ID=$(podman images temp-ee:latest --format "{{.ID}}")
          echo "Built image ID: $IMAGE_ID"
          
          # Show image size
          echo "=== Image Size ==="
          podman images temp-ee:latest --format "table {{.Repository}}\t{{.Tag}}\t{{.Size}}"
          
          # Tag with all metadata tags
          TAGS="${{ steps.meta.outputs.tags }}"
          for tag in $TAGS; do
            # Validate tag format (must not start with hyphen or contain invalid characters)
            if [[ "$tag" =~ ^[a-zA-Z0-9][a-zA-Z0-9._/-]*:[a-zA-Z0-9][a-zA-Z0-9._-]*$ ]]; then
              echo "Tagging with: $tag"
              podman tag temp-ee:latest "$tag"
            else
              echo "Skipping invalid tag format: $tag"
            fi
          done

      - name: Test execution environment
        run: |
          echo "=== Testing Execution Environment ==="
          
          # Test that ansible is available and working
          podman run --rm temp-ee:latest ansible --version
          
          # Test that required collections are installed
          echo "=== Installed Collections ==="
          podman run --rm temp-ee:latest ansible-galaxy collection list
          
          # Test that cisco.asa collection is available
          echo "=== Testing cisco.asa collection ==="
          podman run --rm temp-ee:latest ansible-doc cisco.asa.asa_command || echo "cisco.asa.asa_command documentation not found, but collection may still be functional"
          
          # Test that ansible.netcommon collection is available
          echo "=== Testing ansible.netcommon collection ==="
          echo "Listing available connection plugins from ansible.netcommon:"
          podman run --rm temp-ee:latest ansible-doc -t connection -l | grep netcommon || echo "Warning: No netcommon connection plugins listed"
          
          # SECURITY TEST: Verify NO package managers present (UBI Micro advantage)
          echo "=== Security Verification: Package Managers ==="
          echo "Verifying that package managers are NOT present (minimal attack surface)..."
          if podman run --rm temp-ee:latest which dnf 2>/dev/null; then
            echo "ERROR: dnf found in image (should not be present in UBI Micro)"
            exit 1
          fi
          if podman run --rm temp-ee:latest which yum 2>/dev/null; then
            echo "ERROR: yum found in image (should not be present in UBI Micro)"
            exit 1
          fi
          if podman run --rm temp-ee:latest which microdnf 2>/dev/null; then
            echo "ERROR: microdnf found in image (should not be present in UBI Micro)"
            exit 1
          fi
          if podman run --rm temp-ee:latest which rpm 2>/dev/null; then
            echo "ERROR: rpm found in image (should not be present in UBI Micro)"
            exit 1
          fi
          echo "✓ PASSED: No package managers found - minimal attack surface confirmed"
          
          # SECURITY TEST: Verify NO build tools present
          echo "=== Security Verification: Build Tools ==="
          echo "Verifying that build tools are NOT present in runtime..."
          if podman run --rm temp-ee:latest which gcc 2>/dev/null; then
            echo "ERROR: gcc found in image (build tool should not be in runtime)"
            exit 1
          fi
          echo "✓ PASSED: No build tools found - clean runtime image"
          
          # Verify running as non-root
          echo "=== Security Verification: Non-Root User ==="
          USER_ID=$(podman run --rm temp-ee:latest id -u)
          if [ "$USER_ID" = "0" ]; then
            echo "ERROR: Container running as root (should be UID 1000)"
            exit 1
          fi
          echo "✓ PASSED: Running as UID $USER_ID (non-root)"

      - name: Push to registry
        id: push
        if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/playbook-nest') || (github.event_name == 'workflow_dispatch' && inputs.push_to_registry)
        run: |
          echo "=== Pushing to Container Registry ==="
          TAGS="${{ steps.meta.outputs.tags }}"
          MANIFEST_DIGEST=""
          for tag in $TAGS; do
            # Validate tag format before pushing
            if [[ "$tag" =~ ^[a-zA-Z0-9][a-zA-Z0-9._/-]*:[a-zA-Z0-9][a-zA-Z0-9._-]*$ ]]; then
              echo "Pushing: $tag"
              PUSH_OUTPUT=$(podman push "$tag" --digestfile=/tmp/digest.txt)
              # Capture the manifest digest from the first push (all tags point to same manifest)
              if [ -z "$MANIFEST_DIGEST" ] && [ -f /tmp/digest.txt ]; then
                MANIFEST_DIGEST=$(cat /tmp/digest.txt)
                echo "Captured manifest digest: $MANIFEST_DIGEST"
              fi
            else
              echo "Skipping push of invalid tag format: $tag"
            fi
          done
          
          # Set the manifest digest as output for attestation
          if [ -n "$MANIFEST_DIGEST" ]; then
            echo "digest=$MANIFEST_DIGEST" >> $GITHUB_OUTPUT
            echo "Successfully captured manifest digest for attestation"
          else
            echo "Warning: Could not capture manifest digest"
          fi

      - name: Setup Docker config for attestation
        if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/playbook-nest') || (github.event_name == 'workflow_dispatch' && inputs.push_to_registry)
        run: |
          # Create docker config directory
          mkdir -p ~/.docker
          
          # Copy podman auth to docker config location for attestation action
          # Podman auth is stored in ~/.config/containers/auth.json or ${XDG_RUNTIME_DIR}/containers/auth.json
          if [ -f "${XDG_RUNTIME_DIR}/containers/auth.json" ]; then
            cp "${XDG_RUNTIME_DIR}/containers/auth.json" ~/.docker/config.json
            echo "Copied podman auth from XDG_RUNTIME_DIR"
          elif [ -f ~/.config/containers/auth.json ]; then
            cp ~/.config/containers/auth.json ~/.docker/config.json
            echo "Copied podman auth from ~/.config/containers/auth.json"
          elif [ -f /run/containers/$(id -u)/auth.json ]; then
            cp /run/containers/$(id -u)/auth.json ~/.docker/config.json
            echo "Copied podman auth from /run/containers"
          else
            echo "Warning: Could not find podman auth file, checking /run/user"
            if [ -f "/run/user/$(id -u)/containers/auth.json" ]; then
              cp "/run/user/$(id -u)/containers/auth.json" ~/.docker/config.json
              echo "Copied podman auth from /run/user"
            else
              echo "Error: No podman auth file found"
              exit 1
            fi
          fi
          
          # Verify the config was copied
          echo "Docker config location:"
          ls -la ~/.docker/config.json
        
      - name: Generate artifact attestation
        if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/playbook-nest') || (github.event_name == 'workflow_dispatch' && inputs.push_to_registry)
        uses: actions/attest-build-provenance@v1
        with:
          subject-name: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          subject-digest: ${{ steps.push.outputs.digest }}
          push-to-registry: true

  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest
    needs: build-execution-environment
    if: always() && needs.build-execution-environment.result == 'success'
    permissions:
      contents: read
      security-events: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install ansible-builder
        run: |
          python -m pip install --upgrade pip
          pip install ansible-builder>=3.0.0

      - name: Prepare build context
        run: |
          # Copy the ansible requirements to root for EE build
          cp ansible/requirements.yml ./

      - name: Build execution environment for scanning
        run: |
          ansible-builder build \
            --file execution-environment.yml \
            --tag scan-ee:latest \
            --verbosity 1

      - name: Setup Trivy
        uses: aquasecurity/setup-trivy@v0.2.4
        with:
          version: 'v0.66.0'

      - name: Run Trivy vulnerability scanner with podman
        run: |
          # Export image to tar file for scanning (podman socket not available in GitHub Actions)
          echo "Exporting image to tar file for scanning..."
          podman save scan-ee:latest -o scan-ee.tar
          
          # Scan the tar file with trivy
          trivy image --format sarif --output trivy-results.sarif --input scan-ee.tar

      - name: Upload Trivy scan results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'
